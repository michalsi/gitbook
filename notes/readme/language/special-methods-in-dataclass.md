---
icon: dash
---

# Special Methods in @dataclass

{% hint style="info" %}
Special methods (`__init__`, `__eq__`, `__hash__`, `__repr__`) are automatically generated by `@dataclass` to handle initialization, comparison, hashing, and string representation. Understanding them helps in customizing class behavior.
{% endhint %}

***

### Special Methods Deep Dive 🔍

```ascii
Class Special Methods
┌─────────────────────────────────┐
│            @dataclass           │
├─────────────────────────────────┤
│ __init__   → Initialization     │
│ __eq__     → Equality Compare   │
│ __hash__   → Hash Generation    │
│ __repr__   → String Represent.  │
└─────────────────────────────────┘
```

### 1. `__init__` Method 🏗️

#### What it Does

* Initializes class attributes
* Called when creating new instances
* Sets default values

#### Auto-generated vs Manual

```python
# What you write:
@dataclass
class Person:
    name: str
    age: int = 0

# What @dataclass generates:
class Person:
    def __init__(self, name: str, age: int = 0):
        self.name = name
        self.age = age
```

#### Custom `__init__`

```python
@dataclass
class Person:
    name: str
    age: int
    
    def __init__(self, name: str, age: int):
        if age < 0:
            raise ValueError("Age cannot be negative")
        self.name = name
        self.age = age
```

### 2. `__eq__` Method 🎯

#### What it Does

* Defines equality comparison (`==`)
* Compares all fields by default
* Returns `True` if all fields match

#### Examples

```python
@dataclass
class Point:
    x: int
    y: int

# Auto-generated __eq__
def __eq__(self, other):
    if not isinstance(other, Point):
        return NotImplemented
    return (self.x, self.y) == (other.x, other.y)

# Usage
p1 = Point(1, 2)
p2 = Point(1, 2)
print(p1 == p2)  # True
```

#### Custom Equality

```python
@dataclass
class User:
    username: str
    email: str
    
    def __eq__(self, other):
        if not isinstance(other, User):
            return NotImplemented
        # Compare only by username
        return self.username == other.username
```

### 3. `__hash__` Method 🎲

#### What it Does

* Makes instance usable as dictionary key
* Generated only if class is frozen
* Based on all field values

```ascii
Hash Generation Flow
┌──────────┐    ┌──────────┐    ┌──────────┐
│  Fields  │ →  │  Tuple   │ →  │  Hash    │
└──────────┘    └──────────┘    └──────────┘
```

#### Examples

```python
@dataclass(frozen=True)
class Config:
    host: str
    port: int
    
    # Auto-generated __hash__
    def __hash__(self):
        return hash((self.host, self.port))

# Usage
configs = {
    Config('localhost', 8000): 'dev',
    Config('prod.server', 443): 'prod'
}
```

#### Custom Hash

```python
@dataclass(frozen=True)
class User:
    username: str
    email: str
    
    def __hash__(self):
        # Hash only username
        return hash(self.username)
```

### 4. `__repr__` Method 📝

#### What it Does

* Creates string representation
* Used for debugging/logging
* Shows all fields by default

#### Examples

```python
@dataclass
class Book:
    title: str
    author: str
    year: int = 2000

# Auto-generated __repr__
def __repr__(self):
    return f"Book(title={self.title!r}, author={self.author!r}, year={self.year!r})"

# Usage
book = Book("1984", "Orwell", 1949)
print(book)  # Book(title='1984', author='Orwell', year=1949)
```

#### Custom Representation

```python
@dataclass
class Card:
    suit: str
    value: int
    
    def __repr__(self):
        return f"{self.value} of {self.suit}"

# Usage
card = Card("Hearts", 10)
print(card)  # 10 of Hearts
```

### Practical Combinations 🔧

#### Immutable with Custom Hash

```python
@dataclass(frozen=True)
class CacheKey:
    prefix: str
    id: int
    
    def __hash__(self):
        return hash(f"{self.prefix}:{self.id}")
    
    def __eq__(self, other):
        if not isinstance(other, CacheKey):
            return NotImplemented
        return self.prefix == other.prefix and self.id == other.id
```

#### Custom Everything

```python
@dataclass
class Temperature:
    celsius: float
    
    def __post_init__(self):
        if not isinstance(self.celsius, (int, float)):
            raise TypeError("Temperature must be a number")
    
    def __eq__(self, other):
        if not isinstance(other, Temperature):
            return NotImplemented
        return abs(self.celsius - other.celsius) < 0.01
    
    def __repr__(self):
        return f"{self.celsius}°C"
```

### Pro Tips 💡

1. Use `frozen=True` when you need `__hash__`
2. Override `__eq__` when you need custom equality logic
3. Make `__repr__` readable for debugging
4. Keep `__init__` simple, use `__post_init__` for validation

### Common Patterns 🎭

```python
# Immutable Value Object
@dataclass(frozen=True)
class UserId:
    value: str
    
    def __post_init__(self):
        object.__setattr__(self, 'value', self.value.lower())

# Entity with Custom Equality
@dataclass
class User:
    id: UserId
    name: str
    
    def __eq__(self, other):
        if not isinstance(other, User):
            return NotImplemented
        return self.id == other.id  # Compare only by ID
```

***

These methods make classes more Pythonic and easier to use! 🐍
